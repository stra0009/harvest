require 'bundler/setup'
Bundler.require(:default)

require 'discordrb'
require 'gemini-ai'
require 'dotenv/load'
require 'json'
require 'date'

# Configuration
DISCORD_TOKEN = ENV['DISCORD_BOT_TOKEN']
GEMINI_API_KEY = ENV['GEMINI_API_KEY']
SOURCE_CHANNELS = ENV['SOURCE_CHANNEL_IDS']&.split(',') || []
TARGET_CHANNEL_ID = ENV['TARGET_CHANNEL_ID']

# Initialize Clients
def run
  begin
    main_logic
  rescue => e
    warn "CRITICAL ERROR: #{e.message}"
    warn e.backtrace.join("\n")
    exit(1)
  end
end

def main_logic
  if !DISCORD_TOKEN || !GEMINI_API_KEY || SOURCE_CHANNELS.empty? || !TARGET_CHANNEL_ID
    puts "Error: Missing environment variables."
    exit(1)
  end

  # 1. Collect Messages
  all_messages = []
  
  SOURCE_CHANNELS.each do |channel_id|
    puts "Fetching messages from #{channel_id}..."
    # Fetch last 100 messages (limit for simplicity, or implement pagination for time-based)
    # Using REST API directly avoids Gateway connection overhead
    begin
      msgs = JSON.parse(Discordrb::API::Channel.messages("Bot #{DISCORD_TOKEN}", channel_id, 50))
      
      # Filter for messages from last 24 hours
      one_day_ago = (DateTime.now - 1).to_s
      recent_msgs = msgs.select { |m| m['timestamp'] > one_day_ago }
      
      recent_msgs.each do |msg|
        author = msg['author']['username']
        content = msg['content']
        next if content.strip.empty?
        all_messages << "[#{msg['timestamp']}] #{author}: #{content}"
      end
    rescue => e
      puts "Error fetching channel #{channel_id}: #{e.message}"
    end
  end

  if all_messages.empty?
    puts "No recent messages found."
    return
  end

  puts "Collected #{all_messages.size} messages. Sending to Gemini..."

  # 2. Analyze with Gemini
  client = GeminiAi::Client.new(api_key: GEMINI_API_KEY)
  
  prompt = <<~PROMPT
    You are a helpful project manager. 
    ä»¥ä¸‹ã¯Discordãƒãƒ¼ãƒ ã®é›‘è«‡ã‚„æ®´ã‚Šæ›¸ãã®ãƒ­ã‚°ã§ã™ã€‚
    ã“ã“ã‹ã‚‰æ˜ç¢ºãªã€Œã‚¿ã‚¹ã‚¯ã€ã€Œã‚¢ã‚¤ãƒ‡ã‚¢ã€ã€Œãƒã‚°å ±å‘Šã€ã‚’æŠ½å‡ºã—ã€ãƒªã‚¹ãƒˆåŒ–ã—ã¦ãã ã•ã„ã€‚
    
    1. æŒ¨æ‹¶ã‚„ãŸã ã®é›‘è«‡ã¯ç„¡è¦–ã—ã¦ãã ã•ã„ã€‚
    2. å‰µä½œã‚„é–‹ç™ºã‚„é‹å–¶ã«é–¢é€£ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªé …ç›®ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ã€‚
    3. çµæœã¯å¿…ãšæœ‰åŠ¹ãª **JSONé…åˆ—** å½¢å¼ã®ã¿ã§è¿”ã—ã¦ãã ã•ã„ã€‚
    
    ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆä¾‹:
    [
      {
        "title": "ãƒ­ã‚°ã‚¤ãƒ³ãƒã‚°ã®ä¿®æ­£",
        "description": "ãƒ­ã‚°ã‚¤ãƒ³æ™‚ã«500ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã¨ã®å ±å‘Šã‚ã‚Šã€‚èª¿æŸ»ãŒå¿…è¦ã€‚",
        "priority": "é«˜",
        "original_context": "..."
      }
    ]

    ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ­ã‚°:
    #{all_messages.join("\n")}
  PROMPT

  begin
    result = client.generate_content({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      model: 'gemini-2.0-flash-lite'
    })
    
    # Extract JSON from response
    raw_response = result['candidates'][0]['content']['parts'][0]['text']
    # Clean up markdown code blocks if present
    json_str = raw_response.gsub(/```json/, '').gsub(/```/, '').strip
    tasks = JSON.parse(json_str)
  rescue => e
    puts "Error calling Gemini or parsing JSON: #{e.message}"
    puts "Raw response: #{raw_response}" if raw_response
    return
  end

  if tasks.empty?
    puts "No tasks identified."
    # Optionally notify discord there were no tasks
    return
  end

  # 3. Post to Target Channel
  puts "Found #{tasks.size} tasks. Posting to Discord..."
  
  embeds = tasks.map do |task|
    {
      title: "ğŸ“ #{task['title']}",
      description: task['description'],
      color: 0x00FF00, # Green
      fields: [
        { name: "å„ªå…ˆåº¦", value: task['priority'] || "æ™®é€š", inline: true },
        { name: "å…ƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸", value: task['original_context'] || "N/A" }
      ],
      footer: { text: "Generated by Gemini â€¢ Your Senpai Ace" }
    }
  end

  # Send summary message first
  Discordrb::API::Channel.create_message("Bot #{DISCORD_TOKEN}", TARGET_CHANNEL_ID, "ã‚¢ãƒŠã‚¿ã®å…ˆè¼©ã€ã‚¨ãƒ¼ã‚¹ã§ã™ã€‚\n\næ˜¨æ—¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç¢ºèªã—ã¦ **#{tasks.size}ä»¶** ã®ã‚¿ã‚¹ã‚¯å€™è£œã‚’ã¾ã¨ã‚ã¦ãŠãã¾ã—ãŸã€‚", false, nil)
  
  # Send embeds (Discord allows 10 embeds per message, but safe to send 1 by 1 or batch)
  embeds.each do |embed|
    Discordrb::API::Channel.create_message("Bot #{DISCORD_TOKEN}", TARGET_CHANNEL_ID, nil, false, embed)
    sleep 0.5 # Rate limit safety
  end
  
  puts "Done!"
end

run
