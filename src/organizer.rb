require 'discordrb'
require 'gemini-ai'
require 'dotenv/load'
require 'json'
require 'date'

# Configuration
DISCORD_TOKEN = ENV['DISCORD_BOT_TOKEN']
GEMINI_API_KEY = ENV['GEMINI_API_KEY']
SOURCE_CHANNELS = ENV['SOURCE_CHANNEL_IDS']&.split(',') || []
TARGET_CHANNEL_ID = ENV['TARGET_CHANNEL_ID']

# Initialize Clients
def run
  if !DISCORD_TOKEN || !GEMINI_API_KEY || SOURCE_CHANNELS.empty? || !TARGET_CHANNEL_ID
    puts "Error: Missing environment variables."
    exit(1)
  end

  # 1. Collect Messages
  all_messages = []
  
  SOURCE_CHANNELS.each do |channel_id|
    puts "Fetching messages from #{channel_id}..."
    # Fetch last 100 messages (limit for simplicity, or implement pagination for time-based)
    # Using REST API directly avoids Gateway connection overhead
    begin
      msgs = JSON.parse(Discordrb::API::Channel.messages(DISCORD_TOKEN, channel_id, 50))
      
      # Filter for messages from last 24 hours
      one_day_ago = (DateTime.now - 1).to_s
      recent_msgs = msgs.select { |m| m['timestamp'] > one_day_ago }
      
      recent_msgs.each do |msg|
        author = msg['author']['username']
        content = msg['content']
        next if content.strip.empty?
        all_messages << "[#{msg['timestamp']}] #{author}: #{content}"
      end
    rescue => e
      puts "Error fetching channel #{channel_id}: #{e.message}"
    end
  end

  if all_messages.empty?
    puts "No recent messages found."
    return
  end

  puts "Collected #{all_messages.size} messages. Sending to Gemini..."

  # 2. Analyze with Gemini
  client = GeminiAi::Client.new(api_key: GEMINI_API_KEY)
  
  prompt = <<~PROMPT
    You are a helpful project manager. 
    Below is a log of "scribbled" unstructured messages from a Discord team.
    Your goal is to organize these into clear, actionable tasks.
    
    1. Ignore casual chatter, greetings, or irrelevant comments.
    2. Identify potential tasks, ideas, or bugs reported.
    3. Output the result ONLY as a valid JSON array of objects. 
    
    Format example:
    [
      {
        "title": "Fix login bug",
        "description": "User reported 500 error on login page.",
        "priority": "High",
        "original_context": "..."
      }
    ]

    Messages:
    #{all_messages.join("\n")}
  PROMPT

  begin
    result = client.generate_content({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      model: 'gemini-2.0-flash'
    })
    
    # Extract JSON from response
    raw_response = result['candidates'][0]['content']['parts'][0]['text']
    # Clean up markdown code blocks if present
    json_str = raw_response.gsub(/```json/, '').gsub(/```/, '').strip
    tasks = JSON.parse(json_str)
  rescue => e
    puts "Error calling Gemini or parsing JSON: #{e.message}"
    puts "Raw response: #{raw_response}" if raw_response
    return
  end

  if tasks.empty?
    puts "No tasks identified."
    # Optionally notify discord there were no tasks
    return
  end

  # 3. Post to Target Channel
  puts "Found #{tasks.size} tasks. Posting to Discord..."
  
  embeds = tasks.map do |task|
    {
      title: "üìù #{task['title']}",
      description: task['description'],
      color: 0x00FF00, # Green
      fields: [
        { name: "Priority", value: task['priority'] || "Normal", inline: true },
        { name: "Context", value: task['original_context'] || "N/A" }
      ],
      footer: { text: "Generated by Gemini ‚Ä¢ Serverless Scribble Tasker" }
    }
  end

  # Send summary message first
  Discordrb::API::Channel.create_message(DISCORD_TOKEN, TARGET_CHANNEL_ID, "Found **#{tasks.size}** new potential tasks from the scribble channels:", false, nil)
  
  # Send embeds (Discord allows 10 embeds per message, but safe to send 1 by 1 or batch)
  embeds.each do |embed|
    Discordrb::API::Channel.create_message(DISCORD_TOKEN, TARGET_CHANNEL_ID, nil, false, embed)
    sleep 0.5 # Rate limit safety
  end
  
  puts "Done!"
end

run
